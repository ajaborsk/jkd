Idées en vrac

Exemples d'applications
 - Analyse immobilisations
 - Indicateurs suivi Asset+
 - Analyse activité EFS
 - Compilation (test)
  Par exemple pour un script Arduino

Une application est un fichier (xml ?) qui décrit le graphe (noeuds et arcs).

Types de noeuds :
 - Source de données (brutes)
     - Base de données
     - Fichier(s) Excel
     - h5
     - fichier brut/binaire (.o .h .c .elf ...)
 - Caches
 - Transformateurs de données (import / export)
 - Table
 - Rapport (pdf/html/dhtml/svg...)


Tests à prévoir :
- Tous les Nodes doivent être sérialisables

Pour le serveur WEB, typologie des adresses :
  /application/node/subnode/subsubnode/port.[html/xls/pdf/csv/svg]

Un rapport peut être :
  Offline (contient toutes les données) ou Online (va chercher des données dynamiquement)
  Static (figé et donc Offline) ou Dynamic (Online or Offline)
  Le type est *fixe* : html, pdf, web_page, txt...

  Chaque Noeud est identifié de façon unique
  MAIS il n'est pas envisageable d'avoir une gestion GLOBALE des identifiants
  => gestion arborescente (chaque noeud a un ID unique dans son parent)
  => Cela nécessite un système de requête pour rechercher l'id d'un noeud

  Chaque Noeud a une entrée sous forme de file d'attente (en:queue) qui reçoit les messages entrants et
une sortie sous forme de liste de triggers qui déclenchent l'envoi de message(s) sur d'autres
noeuds lorsque certaines conditions sont remplies.

Evénements qui peuvent déclencher un trigger :
 - Réception d'un message (suivant le message), avant ou après traitement du message
 - Fin d'exécution d'une tâche interne (bloquante ou non)
 - Etapes intermédiaires d'un (long) calcul


Liens, connexions et messages :
-------------------------------

  Un lien ("link") est un concept de haut niveau (pas d'implémentation)
  qui décrit une relation entre deux ports de deux noeuds.

  Une connexion ("connection") est la concrétisation d'un lien.
  Une connexion est créée par une requête ("query") qui est routée depuis
  le noeud source jusqu'au noeud destination. Elle laisse une trace sur son passage,
  de façon à pouvoir router la ou les réponses de façon simple (pas de calcul de routage)
  et sécurisée (seul l'envoyeur de la requête peut recevoir la ou les réponses).
  Les réponses à une requête peuvent être multiples (abonnement à des mises à jour,
  réponses partielles, informations sur l'avancement du traitement d'une requête complexe...)
  Une connexion peut être fermée par une réponse définitive à une requête (mais ce n'est
  pas impératif)

  Les messages sont utilisés pour créer des connexions (requêtes) et transmettre les
  réponses et les éventuelles erreurs. Ils sont constitués d'un dictionnaire (hash), sérialisé ou non suivant
  le mode de transmission.

  Chaque message comporte l'un des trois mots-clefs : 'query', 'reply' ou 'error'.
  Chaque requête comporte un destinataire final, sous forme d'une addresse complète
  (Fully Qualified Name / fqn /path).

  La transmission d'un message entre deux noeuds (qui peuvent être de simples routeurs)
  comporte des tags particuiers :
  *prox_qid* : proximal query id = identifant local de la requête : créé par l'envoyeur
  pour les requêtes et transmis par l'envoyeur pour les réponses
  *prox_src* : envoyeur (sous un format qui dépend du type de connection)
  *prox_dst* : destinataire (idem).



Trame d'un message :
 - src : id du noeud d'envoi (adresse hiérarchique ?)
 - dst : id du noeud destination (adresse hiérarchique ?)
 - qid : id de la requête
 - Charge utile :

Routage Aller d'un message :
 - Principe : Toujours passer par le noeud parent, dans la perspective de
            gérer (ultérieurement) les droits d'accès

Routage Retour d'un message :
 - Utiliser les prox_qid => facile


